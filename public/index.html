<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>YouTube Audio + Waveform</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 50px; }
    textarea, input { width: 100%; }
    textarea { height: 100px; margin-bottom: 10px; }
    button { margin-top: 10px; padding: 5px 10px; }
    .result { margin-top: 20px; font-weight: bold; }
  </style>
</head>
<body>

  <h2>Download YouTube Audio</h2>
  <input type="text" id="ytUrl" placeholder="Enter YouTube URL">
  <button onclick="downloadAudio()">Download Audio</button>

  <audio id="audioPlayer" controls>
    <source id="audioSource" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <h2>Waveform</h2>
  <canvas id="waveformCanvas" width="1000" height="200" style="border:1px solid #ccc;"></canvas>

  <h2>Frequency Spectrum</h2>
  <canvas id="canvas2" width="1000" height="200" style="border:1px solid #ccc;"></canvas>

<script>
const audio = document.getElementById("audioPlayer");
const audioSource = document.getElementById("audioSource");
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const source = audioCtx.createMediaElementSource(audio);
const analyser = audioCtx.createAnalyser();
source.connect(analyser);
analyser.connect(audioCtx.destination);

analyser.fftSize = 2048;
const canvas2 = document.getElementById("canvas2");
const ctx2 = canvas2.getContext("2d");
let freqAnimationRunning = false;
audio.volume = 0.5;

const numBuckets = 10;
let globalMaxDB = -80;

// --- Frequency spectrum ---
function getFrequencyBucketsLogDB() {
  const floatArray = new Float32Array(analyser.frequencyBinCount);
  analyser.getFloatFrequencyData(floatArray);

  const buckets = [];
  const sampleRate = audioCtx.sampleRate;
  const fftSize = analyser.fftSize;
  const binFreq = sampleRate / fftSize;
  const minFreq = 20;
  const maxFreq = 20000;

  for (let i = 0; i < numBuckets; i++) {
    const freqStart = minFreq * Math.pow(maxFreq / minFreq, i / numBuckets);
    const freqEnd = minFreq * Math.pow(maxFreq / minFreq, (i + 1) / numBuckets);
    const startBin = Math.floor(freqStart / binFreq);
    const endBin = Math.min(Math.floor(freqEnd / binFreq), floatArray.length - 1);

    let sum = 0;
    for (let j = startBin; j <= endBin; j++) sum += floatArray[j];
    const avgDB = sum / (endBin - startBin + 1);
    buckets.push(avgDB);
  }

  const minDB = -80;
  const ceiling = 1;
  return buckets.map(db => {
    let val = (db - minDB) / (globalMaxDB - minDB);
    val = Math.max(0, Math.min(1, val));
    return val * ceiling;
  });
}

function drawFrequencies() {
  requestAnimationFrame(drawFrequencies);
  const buckets = getFrequencyBucketsLogDB();
  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
  const barWidth = canvas2.width / buckets.length;

  buckets.forEach((val, i) => {
    const barHeight = val * canvas2.height;
    ctx2.fillStyle = "#4caf50";
    ctx2.fillRect(i * barWidth, canvas2.height - barHeight, barWidth - 2, barHeight);
  });
}

// --- Waveform helper ---
function downsampleWaveform(data, width) {
  const downsampled = [];
  const factor = Math.floor(data.length / width);

  for (let i = 0; i < width; i++) {
    const slice = data.slice(i * factor, (i + 1) * factor);
    if (slice.length === 0) {
      downsampled.push({ min: 0, max: 0 });
      continue;
    }
    let sumSquares = 0;
    slice.forEach(v => sumSquares += v * v);
    const rms = Math.sqrt(sumSquares / slice.length);
    downsampled.push({ min: -rms, max: rms });
  }
  return downsampled;
}

function animateWaveform(data, audio) {
  const canvas = document.getElementById("waveformCanvas");
  const ctx = canvas.getContext("2d");
  const middleY = canvas.height / 2;
  const amplitude = middleY;
  const waveform = downsampleWaveform(data, canvas.width);

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const progress = audio.currentTime / audio.duration;
    const progressX = Math.floor(progress * canvas.width);

    for (let x = 0; x < waveform.length; x++) {
      const { min, max } = waveform[x];
      const y1 = middleY - max * amplitude;
      const y2 = middleY - min * amplitude;
      ctx.fillStyle = x < progressX ? "#4caf50" : "#ccc";
      ctx.fillRect(x, Math.min(y1, y2), 1, Math.abs(y2 - y1));
    }
    requestAnimationFrame(draw);
  }
  draw();
}

// --- Download + display audio ---
/*
async function downloadAudio() {
  const ytUrl = document.getElementById("ytUrl").value;
  if (!ytUrl) return alert("Please enter a YouTube URL");

  const res = await fetch(`/download-audio?url=${encodeURIComponent(ytUrl)}`);
  const data = await res.json();
  if (data.error) return alert("Error: " + data.error);

  audioSource.src = data.url;
  audioPlayer.load();

  const waveformData = data.waveform;
  const maxVal = Math.max(...waveformData);
  const minVal = Math.min(...waveformData);
  const normalizedWaveform = maxVal === minVal
    ? waveformData.map(_ => 0)
    : waveformData.map(v => 2 * (v - minVal) / (maxVal - minVal) - 1);

  audioPlayer.onloadedmetadata = () => {
    animateWaveform(normalizedWaveform, audioPlayer);
    if (!freqAnimationRunning) {
      freqAnimationRunning = true;
      drawFrequencies();
    }
  };

  // Decode audio in AudioContext for globalMaxDB
  const arrayBuffer = await (await fetch(data.url)).arrayBuffer();
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  const channelData = audioBuffer.getChannelData(0);
  globalMaxDB = 20 * Math.log10(Math.max(...channelData.map(v => Math.abs(v))) + 1e-8);
}*/

async function downloadAudio() {
  const ytUrl = document.getElementById("ytUrl").value;
  if (!ytUrl) return alert("Please enter a YouTube URL");

  const res = await fetch(`/download-audio?url=${encodeURIComponent(ytUrl)}`);
  const data = await res.json();
  if (data.error) return alert("Error: " + data.error);

  const audio = document.getElementById("audioPlayer");
  const audioSource = document.getElementById("audioSource");
  audioSource.src = data.url;
  audio.load();
  audio.play();
}

audio.addEventListener("play", async () => {
  if (audioCtx.state === "suspended") await audioCtx.resume();
});
</script>

<h1>Sentiment Checker</h1>
<textarea id="textInput" placeholder="Type your text here..."></textarea>
<br>
<button onclick="checkSentiment()">Check Sentiment</button>
<div class="result" id="result"></div>

<script>
async function checkSentiment() {
  const text = document.getElementById("textInput").value;
  if (!text) return alert("Please enter some text.");

  const response = await fetch("/sentiment", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text })
  });

  const data = await response.json();
  document.getElementById("result").innerHTML =
    `Score: ${data.score} <br>
     Comparative: ${data.comparative} <br>
     Words: ${data.words.join(", ")}`;
}
</script>
</body>
</html>
